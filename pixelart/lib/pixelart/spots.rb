module Pixelart

class Image


def spots_hidef( spot=10,
                   spacing: 0,
                   center: nil,
                   radius: nil,
                   background: nil,
                   lightness: nil,
                   odd: false )

  width  = @img.width*spot+(@img.width-1)*spacing
  height = @img.height*spot+(@img.height-1)*spacing

  ## puts "  #{width}x#{height}"

  ## settings in a hash for "pretty printing" in comments
  settings = { spot: spot
             }

  settings[ :spacing ] = spacing  if spacing
  settings[ :center ]  = center  if center
  settings[ :radius ] = radius  if radius
  settings[ :background ] = background  if background
  settings[ :lightness ] = lightness  if lightness
  settings[ :odd ] = odd   if odd


  v = Vector.new( width, height, header: <<TXT )
generated by pixelart/v#{VERSION} on #{Time.now.utc}

spots_hidef with settings:
    #{settings.to_json}
TXT


  min_center, max_center = center ? center : [0,0]
  min_radius, max_radius = radius ? radius : [0,0]

  ## note: allow passing in array of colors (will get randomally picked)
  background_colors = if background
                        ## check for array; otherwise assume single color passed in
                        background_ary = background.is_a?( Array) ? background : [background]
                        background_ary.map { |background| Color.parse( background ) }
                      else
                        [0]   # transparent (default - no background)
                      end


  min_lightness, max_lightness = lightness ? lightness : [0.0,0.0]


   @img.width.times do |x|
      @img.height.times do |y|
         color = @img[ x, y ]

         if color == 0   ## transparent
           next if background.nil?

           color = if background_colors.size == 1
                     background_colors[0]
                   else  ## pick random background color
                     background_colors[ rand( background_colors.size ) ]
                   end
         end


         if lightness
          ## todo/check: make it work with alpha too
          h,s,l = Color.to_hsl( color, include_alpha: false )

           h = h % 360    ## make sure h(ue) is always positive!!!

           ## note: rand() return between 0.0 and 1.0
           l_diff = min_lightness +
                     (max_lightness-min_lightness)*rand()

           lnew = [1.0, l+l_diff].min
           lnew = [0.0, lnew].max

           ## print " #{l}+#{l_diff}=#{lnew} "

           color = Color.from_hsl( h,
                                   [1.0, s].min,
                                   lnew )
         end

         ## note: return hexstring with leading #
         # e.g.    0 becomes #00000000
         #        and so on
         color_hex = Color.to_hex( color, include_alpha: true )

         cx_offset,
         cy_offset = if center  ## randomize (offset off center +/-)
                       [(spot/2 + min_center) + rand( max_center-min_center ),
                        (spot/2 + min_center) + rand( max_center-min_center )]
                     else
                       [spot/2,   ## center
                        spot/2]
                     end

         cx = x*spot + x*spacing + cx_offset
         cy = y*spot + y*spacing + cx_offset

         r = if radius ## randomize (radius +/-)
                       min_radius + rand( max_radius-min_radius )
                     else
                       spot/2
                     end

         cx += spot/2   if odd && (y % 2 == 1)  ## add odd offset


         v.circle( cx: cx, cy: cy, r: r, fill: color_hex)
      end
    end
  v
end  ## method spots_hidef
alias_method :spots_hd, :spots_hidef


def spots( spot=10,
              spacing: 0,
              center: nil,
              radius: nil,
              background: nil,
              lightness: nil,
              odd: false )

  v = spots_hidef( spot,
        spacing: spacing,
        center: center,
        radius: radius,
        background: background,
        lightness: lightness,
        odd: odd )

  v.to_image
end


end # class Image
end # class Pixelart

